var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = RecursiveDicts\nDocTestSetup = quote\n    using RecursiveDicts\nend","category":"page"},{"location":"#RecursiveDicts","page":"Home","title":"RecursiveDicts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A RecursiveDict is a wrapped Dict, where values may always be a Dict (or RecursiveDict) with the same type parameters.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It's a drop-in replacement for a standard Dict:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> rdict = RecursiveDict(:a => 1, :b =>2)\nRecursiveDict{Symbol, Int64} with 2 entries:\n  :a => 1\n  :b => 2\n\njulia> rdict[:c] = Dict(:d => 5, :e => 20)\nDict{Symbol, Int64} with 2 entries:\n  :d => 5\n  :e => 20\n\njulia> rdict\nRecursiveDict{Symbol, Int64} with 3 entries:\n  :a => 1\n  :b => 2\n  :c => RecursiveDict{Symbol, Int64}(:d=>5, :e=>20)\n\njulia> rdict[:f] = Dict(\"str\" => 7)\nERROR: MethodError: Cannot `convert` an object of type\n  RecursiveDict{String, Int64} to an object of type\n  Union{Int64, RecursiveDict{Symbol, Int64}}\n[...]","category":"page"},{"location":"#Why-Does-the-Type-Signature-Look-Like-That?","page":"Home","title":"Why Does the Type Signature Look Like That?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Type parameters express the free variables in the type. In a Dict{K,V}, the keytype and valtype are both free, so K and V are both the keytype and valtype, and the free parameters.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> d = Dict{Int,String}(1 => \"one\", 2 => \"two\")\nDict{Int64, String} with 2 entries:\n  2 => \"two\"\n  1 => \"one\"\n\njulia> typeof(d)\nDict{Int64, String}\n\njulia> keytype(d)\nInt64\n\njulia> valtype(d)\nString","category":"page"},{"location":"","page":"Home","title":"Home","text":"With a RecursiveDict, the free parameters are the keytype, and whatever value type other than that sort of RecursiveDict is allowed, so the above identity doesn't hold.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> rd = RecursiveDict{Int,String}(1 => \"one\", 2 => \"two\")\nRecursiveDict{Int64, String} with 2 entries:\n  2 => \"two\"\n  1 => \"one\"\n\njulia> typeof(rd)\nRecursiveDict{Int64, String}\n\njulia> keytype(rd)\nInt64\n\njulia> valtype(rd)\nUnion{String, RecursiveDict{Int64, String}}","category":"page"},{"location":"","page":"Home","title":"Home","text":"This fact is why RecursiveDicts exists, since it makes it impossible to specify a recursive container without wrapping it in a struct.","category":"page"},{"location":"#Docstring","page":"Home","title":"Docstring","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [RecursiveDicts]","category":"page"},{"location":"#RecursiveDicts.RecursiveDict","page":"Home","title":"RecursiveDicts.RecursiveDict","text":"RecursiveDict{K,V} <: AbstractDict{K,Union{V,RecursiveDict}}\n\nA Dict where an instance of itself is always a valid value.  So a RecursiveDict{String,String} has String keys, and the values may be either Strings or a RecursiveDict{String,String}. It's harmless to write this as RecursiveDict{String,Union{String,RecursiveDict{String,String}}}, although it isn't necessary, and as the signature gestures at, one does have to provide the base case eventually.\n\nImplements all Base methods which take a Dict.  convert will return the wrapped Dict which provides the data structure, as a shared reference, meaning changes to the provided Dict will be seen in the RecursiveDict, so this data structure may be used anywhere which expects a Dict, with a bit of care.\n\nA Dict{K,V} may also be converted to a RecursiveDict{K,V}, without copying.\n\n\n\n\n\n","category":"type"}]
}
